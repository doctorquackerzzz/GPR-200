//Overall Source: Peter Shirley's RayTracing in One Weekend github.io
//Modifications made by: Nico Omenetto
//Base Functions given by: Daniel Buckstein
//
//Chapter List from Peter Shirley's Ray Tracing in One Weekend github.io used:
//Chapter 4 (RAYS): https://raytracing.github.io/books/RayTracingInOneWeekend.html#rays,asimplecamera,andbackground
//Chapter 5 (Adding a Sphere): https://raytracing.github.io/books/RayTracingInOneWeekend.html#addingasphere
//Chapter 6 (Surface Normal, and Multiple Spheres): https://raytracing.github.io/books/RayTracingInOneWeekend.html#surfacenormalsandmultipleobjects
//Chapter 7 (Antialiasing): https://raytracing.github.io/books/RayTracingInOneWeekend.html#antialiasing



//void mainImage(out vec4 fragColor, in vec2 fragCoord) // original Shadertoy Output function
//{
    // Normalized pixel coordinates (from 0 to 1)
    //vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Output to screen
    //fragColor = vec4(col,1.0);
//}

//hit record struct from chapter 6
struct hit_record {
    vec3 point; 
    vec3 normal;
    float temporary;
    bool front_face;
};
    
struct sphere{
	vec3 center;
    float radius;
};

//camera struct, modified from Chapter 7    
struct cam{
        vec3 horizontal;
    vec3 vertical;
    vec3 lowerLeftCorner;
};

void set_face_normal(vec4 rayDirection, vec4 rayOrigin, vec3 outward_normal, out hit_record rec)
{
    rec.front_face = dot(rayDirection.xyz, outward_normal) < 0.0; // front face of the sphere falling on hit record is equal to the dot product of rayDirection and the outward normal, which is less than 0
    //normal = front_face ? outward_normal :-outward_normal; // original normal determinant from the github.io

    if(rec.front_face) // if the front face is hit, then the normal on the hit record, is a positive outward normal
    {
        rec.normal = outward_normal;
    }
    else //if not the front face, then the normal on the hit record is a negative outward normal
    {
        rec.normal = -outward_normal;
        
    }
}
//set camera functions adapted from Chapter 7 of Peter Shirley's Github.io
void set_cam(out cam camera, vec4 origin, float viewportWidth, float viewportHeight, float focal_length)
{
    camera.horizontal = vec3(viewportWidth, 0.0, 0.0);
    camera.vertical= vec3 (0.0, viewportHeight, 0.0);
    camera.lowerLeftCorner = origin.xyz - camera.horizontal/2.0 - camera.vertical/2.0 - vec3(0.0, 0.0, focal_length);
}

//THIS BASE FUNCTION GIVEN BY DANIEL BUCKSTEIN IN THE INSTRUCTIONS
//
// calcViewport: calculate the viewing plane (viewport) coordinate
//    viewport:       output viewing plane coordinate
//    ndc:            output normalized device coordinate
//    uv:             output screen-space coordinate
//    aspect:         output aspect ratio of screen
//    resolutionInv:  output reciprocal of resolution
//    viewportHeight: input height of viewing plane
//    fragCoord:      input coordinate of current fragment (in pixels)
//    resolution:     input resolution of screen (in pixels)
void calcViewport(out vec2 viewport, out vec2 ndc, out vec2 uv,
                  out float aspect, out vec2 resolutionInv,
                  in float viewportHeight, in vec2 fragCoord, in vec2 resolution)
{
    // inverse (reciprocal) resolution = 1 / resolution
    resolutionInv = 1.0 / resolution;
    
    // aspect ratio = screen width / screen height
    aspect = resolution.x * resolutionInv.y;

    // uv = screen-space coordinate = [0, 1) = coord / resolution
    uv = fragCoord * resolutionInv;

    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1
    ndc = uv * 2.0 - 1.0;

    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2)
    viewport = ndc * (vec2(aspect, 1.0) * (viewportHeight * 0.5));
}

//THIS BASE FUNCTION GIVEN TO US BY DANIEL BUCKSTEIN
//
// calcRay: calculate the ray direction and origin for the current pixel
//    rayDirection: output direction of ray from origin
//    rayOrigin:    output origin point of ray
//    viewport:     input viewing plane coordinate (use above function to calculate)
//    focalLength:  input distance to viewing plane
void calcRay(out vec4 rayDirection, out vec4 rayOrigin,
             in vec2 viewport, in float focalLength)
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    rayOrigin = vec4(0.0, 0.0, 0.0, 1.0);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    rayDirection = vec4(viewport.x, viewport.y, -focalLength, 0.0);
}


//unit_vector of a vec4 variable modified from the github.io
vec4 unit_vector(in vec4 vector)
{
 	   return vector/length(vector);
}

//unit_vector of a vec3 variable modified from the github.io
vec3 unit_vector(in vec3 vector)
{
 	   return vector/length(vector);
}

//length squared of a vec3 variable modified from the github.io
//as well as taught to us by DANIEL BUCKSTEIN
float lenSq(in vec3 x)
{
    return dot(x,x);
}

//length squared of a vec4 variable modified from the github.io
//as well as taught to us by DANIEL BUCKSTEIN
float lenSq(in vec4 y)
{
    return dot (y,y);
}

//hit boolean adopted from chapter 5-6 of Peter Shirley's github.io
bool hit(vec3 center, float radius, vec4 rayDirection, vec4 rayOrigin, float temp_max, float temp_min, out hit_record rec)
{
    vec3 originCenterDist = rayOrigin.xyz - center; //the origin of the ray minus the center point
    float a = lenSq(rayDirection); //length squared of the ray's direction
    float half_b = dot(originCenterDist, rayDirection.xyz); //the dot product of the distance between origin and center, and the direction of the ray
    float c = lenSq(originCenterDist) - radius*radius; //length squared of the distance between origin and center minus radius squared
    float discriminant = half_b*half_b - a*c; //discriminant of the dot product of distance between origin and center, and ray's direction, minus the length squared of the rays direction times the length squared of distance minus radius squared

    if (discriminant > 0.0) { // if discriminant is greater than 0, square root the discriminant
        float root = sqrt(discriminant);

        float temp = (-half_b - root) / a; //a temporary variable is equal to the negative dot product of distance and ray direction minus root of discriminant, divided by the length squared of ray direction
        if (temp < temp_max && temp > temp_min) { //if the temporary variable is less than the max, and greater than the min, calculate where the hit is on the sphere and return whether the sphere has been hit
            rec.temporary = temp;
            rec.point = rayOrigin.xyz + (rec.temporary * rayDirection.xyz);
            vec3 outward_normal = (rec.point - center) / radius;
            set_face_normal(rayDirection, rayOrigin, outward_normal, rec);
            return true;
        }

        temp = (-half_b + root) / a; //a temporary variable is equal to the negative dot product of distance and ray direction plus root of discriminant, divided by the length squared of ray direction
        if (temp < temp_max && temp > temp_min) {//if the temporary variable is less than the max, and greater than the min, calculate where the hit is on the sphere and return whether the sphere has been hit
            rec.temporary = temp;
            rec.point = rayOrigin.xyz + ( rec.temporary * rayDirection.xyz );
            vec3 outward_normal = (rec.point - center) / radius;
            set_face_normal(rayDirection, rayOrigin, outward_normal, rec);
            return true;
        }
    }

    return false; // return false if the if statements are not valid
}

//hittable boolean function adopted from chapter 5-6 of Peter Shirley's Github.io
bool hittable (vec4 rayDirection, vec4 rayOrigin, out float temp_max, float temp_min, out hit_record rec, sphere test)
{
    hit_record temp_rec;
    bool hitAnything = false; //initialization of the variable to help determine whether anything was hit
    if (hit(test.center, test.radius, rayDirection, rayOrigin, temp_max, temp_min, temp_rec)) // if something was hit, return the boolean as true and add it to the hit record
    {
        hitAnything = true;
        temp_max = temp_rec.temporary;
        rec = temp_rec;
    }
        
    //return (discriminant > 0.0);
    return hitAnything; //return the boolean variable to show that something was hit
}

//ORIGINAL CALCCOLOR FUNCTION GIVEN TO US BY DANIEL BUCKSTEIN
//
//adopted from chapters 5-6-7 from Peter Shirley's Github.io
//
// calcColor: calculate the color of a pixel given a ray
//    rayDirection: input ray direction
//    rayOrigin:    input ray origin
vec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin, in sphere testSpheres[2])
{
   
   hit_record rec;
    float temp_max = 1.0/0.0;
    
    bool testOne = hittable(rayDirection, rayOrigin, temp_max, 0.0, rec, testSpheres[0]); //first test on the hittable function for the original sphere
    bool testTwo = hittable(rayDirection, rayOrigin, temp_max, 0.0, rec, testSpheres[1]); // second test on the hittable function for the background sphere
    if (testOne || testTwo) // if test one or test two is valid, return the function that multiplies the vec4 of a normal rec additive onto a vec4 of 1, multiplied by a factor of 1/2.
    {
     	 return 0.5 *(vec4(rec.normal, 1.0) + vec4(1.0));
    }
    vec4 unitDirection = unit_vector(rayDirection); // unit direction is equal to the unit vector of the ray's direction

    float hit = 0.5 * (unitDirection.y + 1.0); //hit float variable is equal to the y of unitDirection plus one, multiplied by a factor of 1/2.

    rayDirection = mix(vec4(1.0), vec4(0.5, 0.7, 1.0, 1.0), hit); //rayDirection then equals a mix of vec4 variables, and the hit float
    
    return rayDirection;
}

//random generator in GLSL adopted from outside source:
//
//outside source : 
float randomGen(vec2 rand)
{
    int n = int(rand.x * 40.0 + rand.y * 6400.0);
    n = (n << 13) ^ n;
    return 1.0 - float( (n * (n * n * 15731 + 789221) + \ 1376312589) & 0x7fffffff) / 1073741824.0;
}

//ORIGINAL BASE FUNCTION GIVEN TO US BY DANIEL BUCKSTEIN, WITH VARIOUS SETUP FUNCTIONS APPLIED FROM THE ORIGINAL
//
//modified using chapters 4-7 of Peter Shirley's Github.io
//
// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // viewing plane (viewport) info 
    vec2 viewport, ndc, uv, resolutionInv; //vec2 declarations
    float aspect; //aspect float declaration
    const float viewportHeight = 2.0, focalLength = 1.0; //viewport height and focal length declaration
    cam camera; //camera declaration from the struct
    
    const float samples_per_pixel = 100.0; //samples per pixel constant float variable declaration
    sphere originalSphere; //Sphere Test 1 (Original Sphere)
    sphere greenGroundSphere;//Sphere Test 2 (green ground Sphere)

    originalSphere.center = vec3(0.0, 0.0, -1.0); // Center of Original Sphere
    greenGroundSphere.center = vec3(0.0, -100.5, -1.0); // Center of Green Ground Sphere

    originalSphere.radius = 0.5; //Original Sphere's radius
    greenGroundSphere.radius = 100.0; //Green Ground Sphere's radius

    
    sphere testSpheres[2] = sphere[2](originalSphere, greenGroundSphere); //array declaration of both spheres
   
    vec4 rayDirection, rayOrigin; //ray direction and origin declaration

    // setup
    calcViewport(viewport, ndc, uv, aspect, resolutionInv,
                 viewportHeight, fragCoord, iResolution.xy); // viewport Calculation function call
    calcRay(rayDirection, rayOrigin,
            viewport, focalLength); // ray calculation function call
    set_camera(camera, rayOrigin, aspect*viewportHeight, viewportHeight, focalLength); //camera set function call
    
    vec4 build; //temporary vec4 declaration
    
    for (float iTemp = 0.0; i < samples_per_pixel; i++) // for loop of configuring the camera to match with the vec4 declared a line earlier
    {
        float u = (fragCoord.x + randomGen(fragCoord)) / ((viewportHeight.aspect) - 1.0); //aspect of viewport height calculated along with the random add of the x of fragment Coordinate
        float v = (fragCoord.x + randomGen(fragCoord)) / (viewportHeight- 1.0); //viewport height calculated along with the random add of the x of fragment Coordinate
        rayDirection = vec4(camera.lowerLeftCorner + u * camera.horizontal + v * camera_vertical, 1.0) - rayOrigin; // ray direection is equal to the previous float equations corresponding to an aspect of the camera being manipulated, minus the origin of the ray

        calcRay(rayDirection, rayOrigin, viewport, focalLength); //calculation of ray function call
        
        build += calcColor(rayDirection, rayOrigin, sphereArray); //the vec4 is equal to the additive of the calling of the calcColor function
    }
    
    float scale = 1.0 / samples_per_pixel; //scale float is equal to 1 divided by the samples per pixel
    
    build.x = clamp(build.x *= scale, 0.0, .999); //the vec4's x is equal to the constrainment of the product of it by scale, 0, and a value close to 1
    build.y = clamp(build.y *= scale, 0.0, .999); //the vec4's y is equal to the constrainment of the product of it by scale, 0, and a value close to 1
    build.z = clamp(build.z *= scale, 0.0, .999); //the vec4's z is equal to the constrainment of the product of it by scale, 0, and a value close to 1

    // color
    fragColor = build;

    // TEST COLOR:
    //  -> what do the other things calculated above look like?
    //fragColor = vec4(viewport, 0.0, 0.0);
    //fragColor = vec4(ndc, 0.0, 0.0);
    //fragColor = vec4(uv, 0.0, 0.0);
}



