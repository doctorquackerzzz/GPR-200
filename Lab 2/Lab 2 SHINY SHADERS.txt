#define colorRGB vec3
#define colorRGBA vec4



//simple colors (CLASS MADE ONE)
vec4 myEffect0(in vec2 fragCoord, in vec2 resolution)
{
    //return vec4 (0.0,0.0, 1.0, 0.2);
    //vec3 color = vec3(fragCoord, 0.1);
    //vec3 color = vec3(0.0, 0.5, 0.1);
    
    vec2 uv = fragCoord / iResolution.xy;
    vec3 color = colorRGB(uv, 1);
    
    float alpha = 1.0;
    return colorRGBA(color, alpha);
}


//checkerboard effect
vec4 myEffect1(in vec2 fragCoord, in vec2 resolution)
{
    vec2 uv = fragCoord / iResolution.xy; //same vec2 uv function
    
    //mod result
    float space = 2.0;
    
    // determinant of whether the space on the checkerboard is white or black
    float spaceColorDeterminant = 0.0; 
    
    vec4 white = colorRGBA(1.0, 1.0, 1.0, 1.0); //white
    vec4 black = colorRGBA(0.0, 0.0, 0.0, 1.0); //black
    
    //the lower this is, the worse the viewer's eyesight
    float checkerboardSize = 8.0; 
    
    vec2 grid = mod(floor(fragCoord / checkerboardSize), space);  
     
    if(mod(grid.x + grid.y, space) != spaceColorDeterminant)
        
        // if the modulation does not equal 0, return the white color
        return white;
    
    else if(mod(grid.x + grid.y,space) == spaceColorDeterminant) 
        
        //if x position plus y position equal 0, return black color
        return black;
}

//enlarging and retracting circle
vec4 myEffect2(in vec2 fragCoord, in vec2 resolution)
{
    float center = 0.5; //center point of the circle
    float marginEdge = 0.001; //the sharpness effect of the edge
    
    //the same uv function as before
    vec2 uv = fragCoord / iResolution.xy; 
    
    //the change in radius over time
    float radius = 0.4*abs(sin(iTime)) +.1; 
    
    //point of origin of the circle
    vec2 origin = uv - vec2(center); 
    
    //animation of the enlargment and decreasement of the circle
    float circle = smoothstep(radius-(radius * marginEdge), radius+(radius * marginEdge), dot(origin, origin) * 2.0); 
    
    vec3 render = vec3(circle); //render
    return vec4(render, 1.0);
}


//psychedellic effect
//Glitched TV line effect
//Explanation: Old school TVs when a part of the monitor is either not working or is dysfunctional
//referenced and adapted from https://www.shadertoy.com/view/wlfBWB from user KayKay for the wave function
//------>
//messed around with the wave function to get the Glitched Line effect
vec4 myEffect3(in vec2 fragCoord, in vec2 resolution, in float time)
{
    
    //static gradient vec4
    vec4 staticGradient = vec4(0.0,0.0,0.0,1.0);
    
    // same uv function as before
    vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color, from the main function that we are given at the bottom
    vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4));

    // Output to screen
    if(uv.y<0.5*(1.0-0.9*sin(6.0*time+30000.0*cos(uv.y))))
        
        //return the color changing glitched lines
    	return vec4(col,1.0); 
    
    else 
        // return the static gradient
        return staticGradient; 
}

















void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    //Solid Color  R, G, B, A
    //fragColor = vec4(1.0, 1.0 ,1.0 ,1.0);
    
    //Uncomment each of the effects to view them in action.
    
    //fragColor = myEffect0(fragCoord, iResolution.xy);  //Gradient Color
    //fragColor = myEffect1(fragCoord, iResolution.xy);  //Checkerboard Effect
    //fragColor = myEffect2(fragCoord, iResolution.xy);	//Enlarging Circle Effect
    fragColor = myEffect3(fragCoord, iResolution.xy, iTime); //glitched TV Line effect (referenced from source)
    
    
    
    // Normalized pixel coordinates (from 0 to 1)
    //vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Output to screen
    //fragColor = vec4(col,1.0);
}