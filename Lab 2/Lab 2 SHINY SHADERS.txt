#define colorRGB vec3
#define colorRGBA vec4

vec3 rgb2hsl(vec3 rgb)
{
    vec3 hsl;
    
    return hsl;
}

vec4 myEffect0(in vec2 fragCoord, in vec2 resolution)
{
    //return vec4 (0.0,0.0, 1.0, 0.2);
    //vec3 color = vec3(fragCoord, 0.1);
    //vec3 color = vec3(0.0, 0.5, 0.1);
    
    vec2 uv = fragCoord / iResolution.xy;
    vec3 color = colorRGB(uv, 0.25);
    
    float alpha = 1.0;
    return colorRGBA(color, alpha);
}

vec4 myEffect1(in vec2 fragCoord, in vec2 resolution)
{
    vec2 uv = fragCoord / iResolution.xy;
    
    vec4 white = colorRGBA(1.0, 1.0, 1.0, 1.0);
    vec4 black = colorRGBA(0.0, 0.0, 0.0, 1.0);
    
    float checkerboardSize = 3.0;
    
    vec2 pos = mod(floor(fragCoord / checkerboardSize), 2.0);  
    if(mod(pos.x + pos.y, 2.0) != 0.0)
        return white;
    else if(pos.x + pos.y == 0.0) //Determines the tile color
        return black;
}

vec4 myEffect2(in vec2 fragCoord, in vec2 resolution)
{
    vec2 uv = fragCoord / iResolution.xy;
}


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    //Solid Color  R, G, B, A
    //fragColor = vec4(1.0, 1.0 ,1.0 ,1.0);
    
    //fragColor = myEffect0(fragCoord, iResolution.xy);
    fragColor = myEffect1(fragCoord, iResolution.xy);
    // Normalized pixel coordinates (from 0 to 1)
    //vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Output to screen
    //fragColor = vec4(col,1.0);
}