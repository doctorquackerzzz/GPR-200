#version 300 es
//#version 400

//Main Duty: process VERTEX ATTRIBUTES
// 3D Point in Space
//normal vector
//uv : texture coordinate
//OBJECT SPACE
layout (location = 0) in vec4 aPosition;
layout (location = 1) in vec3 aNormal;
//in vec4 aPosition
//TEXTURE SPACE
//layout (location = 2) in vec2 aTexcoord;
layout (location = 2) in vec4 aTexcoord;

//transformation uniforms
uniform mat4 uModelMat;
uniform mat4 uViewMat;
uniform mat4 uProjMat;
uniform mat4 uViewProjMat;
//out vec4 vColor;

//PER FRAGMENT
out vec4 vNormal;

out vec4 vTexcoord;
out vec4 vPosition;

//LIGHT CREATION
//struct of the light elements
//		lcenter: center of the light source
//      lcolor: color of the light source
//      lintensity: intensity of the light source
struct light
{
	vec4 lcenter;
	vec4 lcolor;
	float lintensity;
};
float square (float x)
{
	return x*x;
}

void initLight(out light lighter, in vec3 center, in vec3 color, in float intensity)
{
	lighter.lcenter = vec4(center, 1.0);
	lighter.lcolor = vec4(color, 1.0);
	lighter.lintensity = intensity;
}

vec4 lambertReflectionCalc (light lighter, vec4 rayOrigin, vec3 position, vec3 normal, vec4 color,vec4 rayDirection)
{
	//LAMBERTIAN REFLECTION
    //
    //Part 1: Diffusion Coefficient
    vec3 lightVec = normalize(lighter.lcenter.xyz - rayDirection.xyz);
	float diffCoef = max(0.0, dot(normal, lightVec)); // the diffusion coefficient is equal to the maximum dot product of the normal and the light vector
    
    //
    //Part 2: Attenuation
    //source: The GLSL SuperBible (https://f.usemind.org/files/b/1/UseMind.ORG_comprehensive-tutorial-and-reference_2015__.pdf)
    //
    float distance = length(rayDirection.xyz - lightVec); //the distance is equal to the length of ray direction minus the light vector
    float attenuation = 6.0 / (square(distance) + 0.0); //attenuation is equal to a number divided by the distance squared plus however much you want to move the distance
    
    //
    //Part 3: Intensity of Diffusion
    //
    
	vec4 diffIntensity = diffCoef* color * lighter.lcolor * attenuation; //the diffusion intensity is equal to the diffusion coefficient times the natural color, times the light color, times the attenuation
    
    //
    //BLINN-PHONG REFLECTANCE
    //
    vec3 rayView = normalize(rayOrigin.xyz - rayDirection.xyz); // the ray's view is equal to the normalized value of the ray's origin minus the ray's direction
    //
    vec3 halfway = normalize(lightVec + rayView); // the halfway vector is equal to the normalization of the light vector plus the ray view
    float spCoeffPlus = pow(max(0.0, dot(normal, halfway)), 256.0); // the spatial coefficient for Blinn-Phong is equal to the pow of the maximum dot product of normal and the halfway vector, as well as a uinputted number by the coder
    
    //
    //SHINY NEW COLOR OWO (disregard that, it's ecstaticness)
    //
     vec4 shinyNewColor = 0.03 * vec4(0.8, 0.4, 0.2, 1.0) + (diffIntensity * color + spCoeffPlus * vec4(0.2, 0.4, 0.8, 1.0)) * lighter.lcolor;  
     return shinyNewColor;
}



void main()
{
//gl_Position = aPosition;

//position in world space (not yet correct)
vec4 pos_world = uModelMat * aPosition;
//gl_Position = pos_world;

//position in camera space (still not working)
//vec4 pos_view = uViewMat* pos_world;
//gl_Position = pos_view

//POSITION PIPELINE
mat4 modelViewMat = uViewMat * uModelMat;
vec4 pos_view = modelViewMat * aPosition;
vec4 pos_clip = uProjMat * pos_view;
gl_Position = pos_clip;

//NORMAL PIPELINE
mat3 normalMat = inverse(transpose(mat3(modelViewMat)));
vec3 nrm_view = normalMat * aNormal;


//TEX COORD PIPLINE
mat4 atlasMat = mat4(1.0, 0.0, 0.0,0.0,
		     0.0, 0.5, 0.0, 0.0,	
		     0.0, 0.0, 1.0, 0.0,
		     0.25, 0.25, 0.0, 1.0);
vec4 uv_atlas = atlasMat * aTexcoord;


//vec4 pos_clip = uProjMat * pos_view;
//vec4 pos_clip = uViewProjMat * pos_world;
gl_Position = pos_clip;


//vColor = pos_view;

//light configuration
light lighterA, lighterB,lighterC;
initLight(lighterA, vec3(-1.0,0.0,0.0),vec3(1.0,1.0,1.0),10.0);
	initLight(lighterB, vec3(0.0,-1.0,1.0),vec3(1.0,1.0,1.0),10.0);
	initLight(lighterC, vec3(1.0,0.0,-1.0),vec3(1.0,1.0,1.0),10.0);


//PER VERTEX
//vColor = aPosition;
// example: output normal as if it's color
//vColor = vec4(aNormal *0.5 + 0.5, 1.0);

//PER FRAGMENT
vNormal = vec4(aNormal, 0.0);
//vNormal = vec4(nrm_view, 0.0);

//vTexcoord = aTexcoord;
vTexcoord = uv_atlas;

//gl_Position = uProjMat*modelViewMat*aTexcoord;
}