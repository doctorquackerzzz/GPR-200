#version 300 es

#ifdef GL_ES
precision highp float;
#endif

// Output attribute
layout (location = 0) out vec4 rtColor;

// Uniforms
uniform mat4 uViewMatrix, uModelMatrix;
uniform sampler2D uTexture;

// Varyings
in vec4 vColor, vPosition;
in vec3 vNormal;
in vec2 vTexCoord;

// light: data structure to hold info about lights
// center:    center of light
// color:     color of light
// intensity: intensity of light

struct light
{
	vec3 lcenter, lcolor;
	float lintensity;
};

// initLight: function to initialize a light
// 	center:    input center of light
// 	color:     input color of light
// 	intensity: input intensity of light

light initLight(in vec3 center, in vec3 color, in float intensity)
{
	light temp;
	
	temp.lcenter = center;
	temp.lcolor = color;
	temp.lintensity = intensity;
	
	return temp;
}

vec3 lambertReflect (in light lighter, in vec3 normal)
{
		vec3 lightVec = normalize(lighter.lcenter);
	
		float diffCoeff = max(0.0, dot(vNormal, lightVec));
		// Calculate attenuation, use tempVec for efficiency
		vec3 tempVec = lighter.lcenter / lighter.lintensity;
		vec3 attenuation = 1.0 / (tempVec + tempVec * tempVec);
		return diffCoeff * attenuation;
}

vec3 reflectLighter(in light lighter, in vec3 normal)
{
	vec3 lightVec = normalize(lighter.lcenter);
	// Calculate reflected light
	vec3 reflectLight = reflect(-lightVec, vNormal);
	return reflectLight;
}

float specularHighlight(float specularCoeff)
{
	specularCoeff *= specularCoeff;
	specularCoeff *= specularCoeff;
	return specularCoeff;
}

void main(){
	
	// Variable declarations
	// Constant to determine number of lights
	const int NUM_LIGHTS = 3;
	
	light lighter[NUM_LIGHTS];

	mat4 modelViewMatrix = uViewMatrix * uModelMatrix;
		
	vec4 finalColor;
	
	vec3 lightPosition, viewVec;
	
	float specularCoeff;
	
	// light for loop
	for (int i = 0; i < NUM_LIGHTS; i++)
	{
		// Light positioned at (i + 1, i + 1, 1) in object space
		lightPosition = vec3(i + 2, i + 2, 1);
		
		// Light positioned at (i + 1, i + 1, 1) in view space
		//lightPosition = mat3(modelViewMatrix) * vec3(i + 1, i + 1, 1);
	
		// Initialize at given position, white light, 1.5 intensity
		lighter[i] = initLight(lightPosition, vec3(1), 1.5);
		
		lambertReflect(lighter[i], vNormal);
		
		viewVec = normalize(lighter[i].lcenter - vec3(vPosition));
		
		// Calculate specular coefficient
		specularCoeff = dot(reflectLighter(lighter[i], vNormal), viewVec) * 0.5 + 0.5;

		

		// Calculate final color for this light
		finalColor += texture(uTexture, vTexCoord) * 
			      vec4(lambertReflect(lighter[i], vNormal) + specularHighlight(specularCoeff) * vec3(0) * lighter[i].lcolor, 1);
	}
	
	// Factor in global light
	finalColor += 0.15 * vec4(1);
	
	// Output color from vertex or fragment shader
	rtColor = finalColor;
	rtColor = vColor;
}