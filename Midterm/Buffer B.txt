// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN
//  -> BUFFER B TAB (scene)

//used https://www.shaderific.com/glsl-functions/ for help with functions
//
//BUFFER B DESCRIPTION:
//Fire initial building

//NOT MY WORK:
//Source used to reference and manipulate:https://www.shadertoy.com/view/4sfBWj
//------------------------------------------------------------
// RENDERING FUNCTIONS

// calcColor: calculate the color of current pixel
//	  vp:  input viewport info
//	  ray: input ray info
color4 calcColor(in sViewport vp, in sRay ray)
{
    // test inputs
    //return color4(ray.direction.xyz == vp.viewportPoint.xyz); // pass
    //return color4(lengthSq(vp.viewportPoint.xy) >= 0.25); // pass
    //return color4(vp.uv, 0.0, 0.0);
    //return color4(vp.ndc, 0.0, 0.0);
    return asPoint(sBasis(vp.viewportPoint.xy, -vp.viewportPoint.z));
}



//------------------------------------------------------------
// SHADERTOY MAIN

// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)

float time;

float n1f0(float p) {
    return fract(sin(p * 1.7227636) * 8.03e2);
}

float n1f1(float p) {
    return fract(sin(p * 1.42736 + 1.12) * 5.1e2);
}

float n1f2(float p) {
    return fract(sin(p * 1.22712 + 12.161) * 5.2e2);
}


float n3f(vec3 p) {
    return fract(n1f0(p.x) + n1f1(p.y) + n1f2(p.z) + n1f0(p.x * 1.613) + n1f1(p.y * 3.112) + n1f2(p.z * 4.112));
}

float n3(vec3 p) {
    vec3 b = floor(p);
    vec3 e = b + vec3(1.0);
    vec3 particleAlignment = smoothstep(vec3(0.0), vec3(1.0), fract(p));
    float c000 = n3f(b);
    float c001 = n3f(vec3(b.x, b.y, e.z));
    float c010 = n3f(vec3(b.x, e.y, b.z));
    float c011 = n3f(vec3(b.x, e.y, e.z));
    float c100 = n3f(vec3(e.x, b.y, b.z));
    float c101 = n3f(vec3(e.x, b.y, e.z));
    float c110 = n3f(vec3(e.x, e.y, b.z));
    float c111 = n3f(e);
    vec4 z = mix(vec4(c000, c100, c010, c110), vec4(c001, c101, c011, c111),  particleAlignment.z);
    vec2 yz = mix(z.xy, z.zw, particleAlignment.y);
    return mix(yz.x, yz.y, particleAlignment.x);
    
}

//the consistency of flame particles in the y direction. The higher each row goes, the more sparratic the particles for the flames go
float flameConsistency( vec3 p )
{
    float f = 0.0;
    p = threebyThree * p;
    f +=     0.5000*n3( p ); p = threebyThree*p*2.02;
    f +=     0.2500*n3( p ); p = threebyThree*p*2.03;
    f +=     0.1250*n3( p ); p = threebyThree*p*2.01;
    f +=     0.0625*n3( p );
    return f/0.9375;
}

float flameConsistency( vec2 p )
{
    return flameConsistency(vec3(p, time));
}


float grid(vec2 p) {
    p = sin(p * 3.1415);
    return smoothstep(-0.9, 0.9, p.x * p.y);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    time = iTime * 0.7;
    
    vec2 uv = fragCoord.xy / iResolution.xy;
    vec2 p = -1.0 + 2.0 * uv;
    p.x *= iResolution.x/iResolution.y;
    p.y *= 0.3;
    p.y -= time * 1.5;
    float combustSpeed = time * 5.2;
    float combustConsistency1 = time * 1.5;
    float combustConsistency2 = time * 0.6;

    vec3 verticalWarp1 = vec3(p, combustConsistency1);
    verticalWarp1.y *= 2.8;
    vec2 offset1 = vec2(flameConsistency(verticalWarp1), flameConsistency(verticalWarp1 + vec3(10.0, 20.0, 50.0)));
    offset1.y *= 0.3;
    offset1.x *= 1.3;

    vec3 verticalWarp2 = vec3(p, combustConsistency2);
    verticalWarp2.y *= 0.8;
    vec2 offset2 = vec2(flameConsistency(verticalWarp2), flameConsistency(verticalWarp2 + vec3(10.0, 20.0, 50.0)));
    offset2.y *= 0.3;
    offset2.x *= 1.3;
    
    vec2 verticalSpace = (p + offset1 * 1.5 + offset2 * 1.9) * 8.0;
    vec3 verticalConsistency = vec3(verticalSpace, combustSpeed);
    float light;
    light = flameConsistency(verticalConsistency);
    light = smoothstep(0.0, 0.85, light);
    light = max(0.0, (light - pow(uv.y * 0.8, 0.6)) * 1.8);
    float r = pow(light , 1.5);
    float g = pow(light , 3.0);
    float b = pow(light , 6.0);
    vec3 combo = vec3(r,g,b);
    //vec3 col = 0.5 + 0.5*cos(iTime+q.xyx+vec3(r,b,g));
    //r = grid(vs);
    
    fragColor = vec4( r,g,b, 1.0);
    
    //vec3 col = 0.5 + 0.5*cos(iTime+q.xyx+vec3(r,b,g));
    //fragColor += vec4 (col, 1.0);
    
    
}
