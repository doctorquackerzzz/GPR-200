// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN
//  -> BUFFER B TAB (scene)

//used https://www.shaderific.com/glsl-functions/ for help with functions
//
//BUFFER B DESCRIPTION:
//Fire initial building

//NOT MY WORK:
//Source used to reference and manipulate:https://www.shadertoy.com/view/4sfBWj
//------------------------------------------------------------
// RENDERING FUNCTIONS

// calcColor: calculate the color of current pixel
//	  vp:  input viewport info
//	  ray: input ray info
color4 calcColor(in sViewport vp, in sRay ray)
{
    // test inputs
    //return color4(ray.direction.xyz == vp.viewportPoint.xyz); // pass
    //return color4(lengthSq(vp.viewportPoint.xy) >= 0.25); // pass
    //return color4(vp.uv, 0.0, 0.0);
    //return color4(vp.ndc, 0.0, 0.0);
    return asPoint(sBasis(vp.viewportPoint.xy, -vp.viewportPoint.z));
}



//------------------------------------------------------------
// SHADERTOY MAIN

// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)

float time; //time variable

//calculations for the floor variable to build the static frames of the flame particles
float n3f(vec3 p) {
    return fract(frameCreation(1.7227636, 8.03e2, p.x) + frameCreation(1.42736 + 1.12,5.1e2,p.y) + frameCreation(1.22712 + 12.161, 5.2e2, p.z) + frameCreation(1.7227636 * 1.613, 8.03e2 * 1.613,p.x * 1.613) + frameCreation((1.42736 + 1.12) *3.112, 5.1e2 *3.112, p.y * 3.112) + n1f2((1.22712 + 12.161) * 4.112, 5.2e2 * 4.112, p.z * 4.112));
}

float n3(vec3 p) {
    vec3 truth = floor(p);
    vec3 fake = truth + vec3(1.0);
    vec3 particleAlignment = smoothstep(vec3(0.0), vec3(1.0), fract(p));
    float c000 = n3f(truth);
    float c001 = n3f(vec3(truth.x, truth.y, fake.z));
    float c010 = n3f(vec3(truth.x, fake.y, truth.z));
    float c011 = n3f(vec3(truth.x, fake.y, fake.z));
    float c100 = n3f(vec3(fake.x, truth.y, truth.z));
    float c101 = n3f(vec3(fake.x, truth.y, fake.z));
    float c110 = n3f(vec3(fake.x, fake.y, truth.z));
    float c111 = n3f(fake);
    vec4 z = mix(vec4(c000, c100, c010, c110), vec4(c001, c101, c011, c111),  particleAlignment.z);
    vec2 yz = mix(z.xy, z.zw, particleAlignment.y);
    return mix(yz.x, yz.y, particleAlignment.x);
    
}

//the consistency of flame particles. The higher each row goes, the more sparratic the particles for the flames go
float flameConsistency( vec3 p )
{
    float f = 0.0;
    p = threebyThree * p;
    f +=     0.5000*n3( p ); p = threebyThree*p*2.02;
    f +=     0.2500*n3( p ); p = threebyThree*p*2.03;
    f +=     0.1250*n3( p ); p = threebyThree*p*2.01;
    f +=     0.0625*n3( p );
    return f/0.9375;
}

float flameConsistency( vec2 p )
{
    return flameConsistency(vec3(p, time));
}


//grid creation for the flame particles
float grid(vec2 p) {
    p = sin(p * 3.1415);
    return smoothstep(-0.9, 0.9, p.x * p.y);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    time = iTime * 0.7;
    
    vec2 uv = fragCoord.xy / iResolution.xy;
    vec2 p = -1.0 + 2.0 * uv;
    p.x *= iResolution.x/iResolution.y;
    p.y *= 0.3;
    p.y -= time * 1.5;
    float combustSpeed = time * 5.2;
    float combustConsistency1 = time * 1.5;
    float combustConsistency2 = time * 0.6;

    //the warping of the flames
    //calculates two different warpings using the calculations of the combustion consistency and the time
    //an offset is then calculated by making a vec3 of the change in flame consistency and multiplying the x and y of the offset by a value
    vec3 verticalWarp1 = vec3(p, combustConsistency1);
    verticalWarp1.y *= 2.8;
    vec2 offset1 = vec2(flameConsistency(verticalWarp1), flameConsistency(verticalWarp1 + vec3(10.0, 20.0, 50.0)));
    offset1.y *= 0.3;
    offset1.x *= 1.3;

    vec3 verticalWarp2 = vec3(p, combustConsistency2);
    verticalWarp2.y *= 0.8;
    vec2 offset2 = vec2(flameConsistency(verticalWarp2), flameConsistency(verticalWarp2 + vec3(10.0, 20.0, 50.0)));
    offset2.y *= 0.3;
    offset2.x *= 1.3;
    
    //the creation of the flame by space, cosistency, and the light, which gives the flame the color it needs
    //the last steps make the flame the color of orange
    vec2 verticalSpace = (p + offset1 * 1.5 + offset2 * 1.9) * 8.0;
    vec3 verticalConsistency = vec3(verticalSpace, combustSpeed);
    float light;
    light = flameConsistency(verticalConsistency);
    light = smoothstep(0.0, 0.85, light);
    light = max(0.0, (light - pow(uv.y * 0.8, 0.6)) * 1.8);
    float red = pow(light , 1.5);
    float green = pow(light , 3.0);
    float blue = pow(light , 6.0);
    vec3 combo = vec3(red,green,blue);
    //vec3 col = 0.5 + 0.5*cos(iTime+q.xyx+vec3(r,b,g));
    //r = grid(vs);
    
    fragColor = vec4( r,g,b, 1.0);
    
    //vec3 col = 0.5 + 0.5*cos(iTime+q.xyx+vec3(r,b,g));
    //fragColor += vec4 (col, 1.0);
    
    
}
